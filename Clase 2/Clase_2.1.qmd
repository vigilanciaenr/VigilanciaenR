---
title: "Clase 2.1"
format: 
  html:
    toc: true                # Habilita la tabla de contenidos
    toc-title: "Índice de Contenidos"  # Título del índice
    toc-depth: 3             # Nivel de profundidad del índice (hasta h3)
    toc-location: left       # Ubicación del índice (izquierda)
footnotes-hover: true # muestra notas al pie
smooth-scroll: true # suaviza el scroll
editor: visual
code-copy: true            # Permite copiar el código desde el documento
---

## 2. Limpieza de datos

En primer lugar para comenzar nuevamente nuestro proceso de limpieza datos vamos a traer nuestro data frame que ya trabajamos anteriormente

```{r, echo=TRUE, results='hide'}

library(readxl)
library(dplyr)

```

```{r}

dengue_limpio <- read_excel("dengue_limpio.xlsx")


```

En primer lugar **cambio las fechas para que esten en el formato adecuado**

```{r}

dengue_limpio <- dengue_limpio %>%
  mutate(across(c("Fecha de toma de muestra", "Fecha de inicio de síntomas", "Fecha Apertura", "Fecha Nacimiento"), as.Date))

```

### 2.1 Creación y modificación de columnas

Para ello vamos a utilizar la función **`mutate()`** del paquete `dplyr.`

Como dije allí, los dos primeros argumentos de `mutate()`son `.data`y `...`.El valor que se pasa a `.data`siempre debe ser un marco de datos. Por lo general se pasa marcos de datos al `.data`argumento utilizando el operador de barra vertical (por ejemplo, `df %>% mutate()`).

El valor que se pasa al `...`argumento debe ser un par nombre-valor o varios pares nombre-valor separados por comas. El `...`argumento es donde se indica si `mutate()`va acrear o modificar columnas en el marco de datos.

Con esto podemos crear y modificar columnas existentes. Además usaremos la **`case_when()`** para que pueda generar una secuencia de condiciones. Esta evalúa cada fórmula bilateral secuencialmente hasta que encuentra una condición que se cumple. Si nunca encuentra una condición que se cumpla, entonces devuelve un `NA`.

Para este ejemplo primero vamos transformar y crear versiones factoriales de variables para que sea más simple:

```{r}

dengue_lim2 <- dengue_limpio %>%
  mutate(clasificación = case_when(
     is.na(Resultado) ~ NA_character_,
    # Casos confirmados
    (Determinación %in% c("Anticuerpos neutralizables", "Antígeno NS1", "Genoma viral") & 
      Resultado %in% c("Positivo", "Reactivo", "Virus dengue sin serotipo")) |
    (Determinación %in% c("IgG DENV", "IgM DENV")) & 
      Resultado %in% c("Positivo", "Reactivo") ~ "confirmado",
    
    Determinación %in% c("IgM CHIKV") &
       Resultado %in% c("Positivo", "Reactivo") ~ "confirmado_chikv",
    
    # Casos sospechosos
    Determinación %in% c("IgG DENV", "IgM DENV","Genoma viral","Anticuerpos neutralizables") & 
      Resultado %in% c("No detectable", "Inespecífico") ~ "sospechoso",
    
     Determinación %in% c("IgM CHIKV") &
       Resultado %in% c("No detectable", "Inespecífico") ~ "sospechoso_chikv",
    
    # Casos negativos
    Determinación %in% c("IgG DENV", "IgM DENV","Genoma viral","Anticuerpos neutralizables") & 
    Resultado %in% c("Negativo", "No reactivo") ~ "negativo",
    
    Determinación %in% c("IgM CHIKV") &
       Resultado %in% c("No detectable", "Inespecífico") ~ "negativo_chikv",
    
    # Casos no procesados
    Resultado %in% c("No procesada", "NA") ~ "no procesado",
    
    # Casos indeterminados
    TRUE ~ "Indeterminado"
  ))


```

**Esto es lo que hicimos arriba**

1.  **`dengue_sheet <- dengue_sheet %>%`**: Esto utiliza el pipe (`%>%`) para aplicar una transformación sobre el dataset `dengue_sheet` y guardar los resultados de vuelta en el mismo dataset.

2.  **`mutate(clasificación = case_when(...))`**:

    -   **`mutate()`** es una función de `dplyr` que se utiliza para crear o modificar columnas en un `data.frame`. Aquí estamos creando una nueva columna llamada `clasificación`.

    -   **`case_when()`** se usa para crear condiciones lógicas. Evalúa las condiciones y devuelve un valor dependiendo de cuál de ellas es verdadera. Funciona como un "si... entonces".

3.  **`determinación %in% c(...) & resultado %in% c(...) ~ "confirmado"`**:

    -   Aquí estamos definiendo los casos "confirmados". Se busca si la columna `determinación` contiene alguno de los valores en el vector `c("Anticuerpos neutralizables", "Antígeno NS1", "Genoma viral")` **y** la columna `resultado` contiene alguno de los valores en el vector `c("Positivo", "Reactivo", "Virus dengue sin serotipo")`.

    -   Si ambas condiciones son verdaderas, el resultado para esa fila será `"confirmado"`.

4.  **`determinación %in% c(...) & resultado %in% c(...) ~ "sospechoso"`**:

    -   Similar al bloque anterior, pero define los casos como "sospechosos". Aquí evaluamos si la columna `determinación` tiene valores como `IgG DENV`, `IgM DENV`, `IgM CHIKV`, y si la columna `resultado` contiene valores como `No detectable` o `Inespecífico`.

5.  **`resultado %in% c("Negativo", "No reactivo") ~ "negativo"`**:

    -   Esta línea evalúa si el `resultado` es "Negativo" o "No reactivo". Si lo es, la fila se clasifica como `"negativo"`. No requiere condiciones adicionales sobre la columna `determinación`.

6.  **`resultado %in% c("No procesada", "NA") ~ "no procesado"`**:

    -   Evalúa si el `resultado` es "No procesada" o `NA` (falta de datos). Si lo es, el caso se clasifica como `"no procesado"`.

7.  **`TRUE ~ "indeterminado"`**:

    -   Este es un "catch-all" que captura cualquier fila que no cumpla con ninguna de las condiciones anteriores. El valor `TRUE` significa "si ninguna de las condiciones anteriores es verdadera", y clasifica esos casos como `"indeterminado"`.

Tambien podriamos realizar esto con una simplificación de la variable "Resultados"

### 2.2 Recodificación de variables

La contracción de variables significa combinar dos o más valores de nuestra variable. Podemos realizar una contracción de variables continuas en categorías o podemos realizar una contracción de categorías en categorías más amplias. Después de contracción de una variable, siempre contiene menos valores posibles (y más amplios) que los que contenía antes de contracción.

Vamos entonces a colapsar la columna "Resultados" en una nueva columna de "resultados_comb"

```{r}

dengue_lim2 <- dengue_lim2 %>%
  mutate(
    resultados_comb = case_when(
      Resultado %in% c("Positivo", "Reactivo", "Virus dengue sin serotipo") ~ "positivo",  # Casos positivos
      Resultado %in% c("Negativo", "No reactivo") ~ "negativo",  # Casos negativos
      Resultado %in% c("Inespecífico", "No detectable", "No procesada") ~ "indeterminado",  # Casos indeterminados
      TRUE ~ NA_character_  # Para valores que no coinciden con las anteriores
    )
  )
```

Esto es lo anterior:

-   **`case_when`**: Evalúa las condiciones de la columna `Resultado`.

-   **`%in%`**: Se usa para verificar si los valores de `Resultado` pertenecen a un conjunto de posibles valores.

-   **`~`**: Asocia la condición con el valor de salida.

-   **`TRUE ~ NA_character_`**: Si un valor no coincide con ninguna condición previa, se asigna `NA` como valor.

Y ahora por ejemplo la convierto en números:

```{r}
dengue_lim2 <- dengue_lim2 %>%
  mutate(
    resultados_num = case_when(
      resultados_comb == "positivo" ~ 1,
      resultados_comb == "negativo" ~ 0,
      resultados_comb == "indeterminado" ~ 2,
      TRUE ~ NA_real_  # Asigna NA a los valores que no coincidan
    )
  )

```

-   **`resultados_comb == "positivo" ~ 1`**: Asigna 1 a la categoría "positivo".

-   **`resultados_comb == "negativo" ~ 0`**: Asigna 0 a la categoría "negativo".

-   **`resultados_comb == "indeterminado" ~ 2`**: Asigna 2 a la categoría "indeterminado".

-   **`NA_real_`**: Especifica que los valores faltantes deben ser numéricos (`NA` en formato numérico).

Ahora puedo realizar la misma comparación que realicé al pirncipio:

```{r}

dengue_lim2 <- dengue_lim2 %>%
  mutate(clasificación_2 = case_when(
    
    # Casos confirmados
    Determinación %in% c("Anticuerpos neutralizables", "Antígeno NS1", "Genoma viral", "IgG DENV", "IgM DENV") &
     resultados_num %in% c(1) ~ "confirmado",
    
    Determinación %in% c("IgM CHIKV") &
     resultados_num %in% c(1) ~ "confirmado_chikv",
    
    
    # Casos sospechosos
    Determinación %in% c("Anticuerpos neutralizables", "Antígeno NS1", "Genoma viral", "IgG DENV", "IgM DENV") &
    resultados_num %in% c(2) ~ "sospechoso",
    
    Determinación %in% c("IgM CHIKV") &
     resultados_num %in% c(2) ~ "sospechoso_chikv",
    
    
    # Casos negativos
    Determinación %in% c("Anticuerpos neutralizables", "Antígeno NS1", "Genoma viral", "IgG DENV", "IgM DENV", "IgM CHIKV") &
    resultados_num %in% c(0) ~ "negativo",
    
     Determinación %in% c("IgM CHIKV") &
     resultados_num %in% c(3) ~ "negativo_chikv",
    
    # Casos no procesados
    Resultado %in% c("No procesada", "NA") ~ "no procesado",
    
    # Si solo Determinación tiene valor y resultados_num es NA
    !is.na(Determinación) & is.na(resultados_num) ~ "solo_determinacion",
    
    # Si solo resultados_num tiene valor y Determinación es NA
    is.na(Determinación) & !is.na(resultados_num) ~ "solo_resultado_num",
    
    TRUE ~ NA_character_  # Para los casos que no coinciden con las categorías anteriores
  ))


```

-   **Caso confirmado**:

    -   Se clasifica como `"confirmado"` cuando:

        -   La columna `Determinación` tiene uno de los valores en el vector `c("Anticuerpos neutralizables", "Antígeno NS1", "Genoma viral", "IgG DENV", "IgM DENV")` **y**

        -   La columna `resultados_num` tiene el valor `1`.

    -   Se clasifica como `"confirmado_chikv"` cuando:

        -   La columna `Determinación` es `"IgM CHIKV"` **y**

        -   La columna `resultados_num` tiene el valor `1`.

-   **Caso sospechoso**:

    -   Se clasifica como `"sospechoso"` cuando:

        -   La columna `Determinación` tiene uno de los mismos valores del caso confirmado **y**

        -   La columna `resultados_num` tiene el valor `2`.

    -   Se clasifica como `"sospechoso_chikv"` cuando:

        -   La columna `Determinación` es `"IgM CHIKV"` **y**

        -   La columna `resultados_num` tiene el valor `2`.

-   **Caso negativo**:

    -   Se clasifica como `"negativo"` cuando:

        -   La columna `Determinación` tiene uno de los valores en `c("Anticuerpos neutralizables", "Antígeno NS1", "Genoma viral", "IgG DENV", "IgM DENV", "IgM CHIKV")` **y**

        -   La columna `resultados_num` tiene el valor `0`.

    -   Se clasifica como `"negativo_chikv"` cuando:

        -   La columna `Determinación` es `"IgM CHIKV"` **y**

        -   La columna `resultados_num` tiene el valor `3`.

-   **Caso no procesado**:

    -   Se clasifica como `"no procesado"` cuando:

        -   La columna `Resultado` tiene los valores `"No procesada"` o `"NA"`.

-   **Si solo tienes valor en `Determinación`** (`!is.na(Determinación) & is.na(resultados_num)`): se clasifica como `"solo_determinacion"`.

-   **Si solo tienes valor en `resultados_num`** (`is.na(Determinación) & !is.na(resultados_num)`): se clasifica como `"solo_resultado_num"`.

*Esto es inneseracio solo es ejemplo para comparar dos columnas.*

*Ahora quiero comparar las dos columnas de clasificación para saber si me trajeron lo mismo:*

```{r}

# No es necesario este paso

dengue_lim2 <- dengue_lim2 %>%
  mutate(
     comparación_clasificación = case_when(
    is.na(clasificación_2) | is.na(clasificación) ~ NA_character_,
      clasificación_2 == clasificación ~ "Coincide",
      TRUE ~ "No coincide"
    )
  )

```

-   **`is.na(clasificación_2) | is.na(clasificación)`**: Esta parte verifica si cualquiera de los dos valores (en `clasificación_2` o en `clasificación`) es `NA`. La condición usa el operador `|` para indicar "o" lógico, lo que significa que si al menos uno de los dos valores es `NA`, la condición será verdadera.

-   **`~ NA_character_`**: Si la condición es verdadera, la nueva columna `comparación_clasificación` se establece como `NA`. Usar `NA_character_` asegura que el tipo de datos en la columna sea carácter, y no se mezcle con otros tipos de `NA` (como numérico).

-   **`clasificación_2 == clasificación`**: Esta parte compara los valores en `clasificación_2` y `clasificación`. Si los dos valores son iguales, la condición será verdadera.

-   **`~ "Coincide"`**: Si la condición es verdadera, la nueva columna `comparación_clasificación` se establece como `"Coincide"`, indicando que los valores coinciden.

-   **`TRUE ~ "No coincide"`**: Esta es una cláusula por defecto que se aplica si ninguna de las

condiciones anteriores es verdadera. Es como el "else" en una estructura `if`-`else`. Si `clasificación_2` y `clasificación` no coinciden y ninguno de los valores es `NA`, entonces la columna `comparación_clasificación` se establece como `"No coincide"`.

```{r}
dengue_diferencias <- dengue_lim2 %>%
  filter(comparación_clasificación == "No coincide")

```

```{r}

# Eliminar una columna

dengue_lim2 <- dengue_lim2 %>% 
  select(-comparación_clasificación)



```

### 2.3 Generación de ID

Vamos a generar un Id de los datos a partir de la fecha de toma de muestra y dni

Para crear un **ID único de caso** basado en las **fechas de toma de muestra de laboratorio** y el **DNI** (o número de identificación), puedes concatenar estos valores en una nueva columna para asegurarte de que cada combinación sea única. A continuación te muestro cómo puedes hacerlo en R utilizando `mutate()` de `dplyr`.

Antes vamos seleccionar los casos con los que vamos a trabajar para que el ID este asociado a esto. Para ello vamos a utilizar la función **`filter()`**

```{r}


# Primero voy a seleccionar solo los casos de Dengue y de Chaco y año 2024

library(dplyr)
library(lubridate)

dengue_lim2 <- dengue_lim2 %>%
  filter(Evento == "Dengue" &
           `Provincia Residencia` == "Chaco" &
           year(`Fecha de toma de muestra`) == 2024)  # Cambia 2024 por el año que quieras filtrar

```

-   **`filter(...)`**:

    -   La función `filter()` de `dplyr` se utiliza para seleccionar filas que cumplen con ciertas condiciones. En este caso, está filtrando las filas del data frame basado en tres condiciones.

-   **`Evento == "Dengue"`**:

    -   Esta condición selecciona solo las filas donde la columna `Evento` es igual a "Dengue". Aquí estás buscando eventos que estén clasificados específicamente como "Dengue".

-   **`Provincia Residencia == "Chaco"`**:

    -   Esta condición selecciona solo las filas donde la columna `Provincia Residencia` es igual a "Chaco". Esto filtra los datos para incluir solo aquellos que están asociados con la provincia de Chaco.

-   **`year(`Fecha de toma de muestra`) == 2024`**:

    -   La función `year()` se utiliza para extraer el año de una columna de tipo fecha. Aquí se está extrayendo el año de la columna `Fecha de toma de muestra` y se está filtrando para que solo se incluyan las filas donde el año es igual a 2024. Nota que para usar `year()`, necesitas tener el paquete `lubridate` cargado.

**Ahora si con nuestro data frame vamos a contruir un ID con numero de documento y fecha de toma de muestra para que tengan valores únicos:**

```{r}


# Crear un ID único de caso

dengue_id <- dengue_lim2 %>%
  mutate(id_caso = paste(`Nro Doc`, `Fecha de toma de muestra`, sep = "_")) %>% 
  mutate(across(where(is.character), ~ na_if(., "*SIN DATO* (*SIN DATO*)")))

dengue_id


```

-   **`mutate(id_caso = paste(`Nro Doc`,`Fecha de toma de muestra`, sep = "_"))`**:

    -   La función `mutate()` de `dplyr` se usa para crear nuevas columnas o modificar columnas existentes en un data frame.

    -   Aquí se está creando una nueva columna llamada `id_caso` que se construye concatenando el valor de la columna `Nro Doc` y la columna `Fecha de toma de muestra`, separados por un guion bajo (`_`).

    -   La función `paste()` se utiliza para concatenar los valores de las dos columnas. El argumento `sep = "_"` especifica que el separador entre los valores debe ser un guion bajo.

-   **`mutate(across(where(is.character), ~ na_if(., "*SIN DATO* (*SIN DATO*)")))`**:

    -   La función `across()` permite aplicar una función a múltiples columnas seleccionadas.

    -   `where(is.character)` selecciona todas las columnas que son de tipo carácter.

    -   `~ na_if(., "*SIN DATO* (*SIN DATO*)")` es una función anónima (también conocida como función lambda) que aplica `na_if()` a cada columna seleccionada. `na_if()` reemplaza los valores especificados con `NA`.

    -   En este caso, `na_if(., "*SIN DATO* (*SIN DATO*)")` reemplaza todas las ocurrencias del texto "*SIN DATO* (*SIN DATO*)" con `NA` en las columnas de carácter.

### 2.4 Exportar tabla limpia

```{r}

library(writexl)

# Guardar en una ruta específica

write_xlsx(dengue_lim2, path = "C:/Users/flor/Desktop/cursor_2024/VigilanciaenR/dengue_id.xlsx")

```
